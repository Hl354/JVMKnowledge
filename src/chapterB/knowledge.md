## 确定对象是否还会被使用的算法
引用计数法：给对象添加一个引用计数器，每当有一个对象引用它时就加一，当引用失效时就减一。
计数器为零就不在可用。优点是实现简单、判断效率高，缺点是无法解决循环引用的问题。

可达性分析：通过一些的称为GC ROOTS的节点作为起始点，从这些节点向下搜索，当一个对象到GC ROOTS
没有任何引用链相连时，则证明对象是不可用的。一般可作为GC ROOTS的对象为虚拟机栈中引用的对象、方法区中静态
属性引用的对象、方法区中常量引用的对象以及本地方法栈中引用的对象。

## 引用类型
强引用；类似new操作产生的引用，只要强引用存在，垃圾回收器永远不会回收掉被引用的对象。

软引用：一些有用但并非必须的对象，在系统将要发生内存溢出之前，将会把这些对象列进回收范围
之中进行第二次回收。SoftReference类实现，

弱引用：非必须对象，被弱引用关联的对象只能生存到下一次垃圾回收发生之前。WeakReference类实现，

虚引用：最弱的引用，一个对象是否有虚引用的存在，完全不会对其生存时间造成影响。PhantomReference类实现，

## 垃圾回收算法

标记-清除算法：首先标记所有需要回收的对象（引用计数器法或者可达性分析），在标记完成后，
统一回收所有被标记的对象。这种算法不足之处有两个，一是效率不高，而是产生内存碎片。

复制算法：将内存按容量划分为相等的两块，每次只使用其中的一块，当这一块内存用完了，就将
还存活的对象复制到另一块上去，然后再把已使用的一块内存清理掉。不足是将内存缩小为原来的一半。

标记-整理算法：前期与标记-清楚算法一样，但后续是先让所有存活的对象都向一端移动，然后
直接清理掉端边界以外的内存。

分代收集算法：将内存堆进行细分，首先分为新生代和老年代（用于存放新生代中经过多次垃圾回收仍然存活的对象），其次新生代再分为Eden区和两个Survivor区，
在新生代中选择复制算法，老年代选择标记-清除或者标记-整理算法。